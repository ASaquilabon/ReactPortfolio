{"ast":null,"code":"import { useState, useRef, useEffect } from 'react';\n\nfunction useObserver(_ref) {\n  var threshold = _ref.threshold,\n      _ref$rootMargin = _ref.rootMargin,\n      rootMargin = _ref$rootMargin === void 0 ? '0px' : _ref$rootMargin;\n\n  var _useState = useState(),\n      inView = _useState[0],\n      setInView = _useState[1];\n\n  var ref = useRef();\n  var iObserverRef = useRef();\n  useEffect(function () {\n    var options = {\n      root: null,\n      rootMargin: rootMargin,\n      threshold: threshold\n    };\n    iObserverRef.current = new IntersectionObserver(function (entries) {\n      if (inView !== entries[0].isIntersecting) {\n        setInView(entries[0].isIntersecting);\n      }\n    }, options);\n  }, []);\n  useEffect(function () {\n    // @ts-ignore\n    if (ref.current) iObserverRef.current.observe(ref.current);\n    return function () {\n      if (ref.current) {\n        // @ts-ignore\n        iObserverRef.current.unobserve(ref.current); // @ts-ignore\n\n        iObserverRef.current.disconnect();\n      }\n    };\n  }, [ref.current]);\n  return {\n    inView: inView,\n    ref: ref\n  };\n}\n\nexport { useObserver };","map":{"version":3,"sources":["../src/index.tsx"],"names":["useObserver","threshold","rootMargin","inView","setInView","useState","ref","useRef","iObserverRef","useEffect","options","root","entries"],"mappings":";;SAOgBA,W,CAAAA,I,EAAAA;MAAcC,SAAAA,GAAAA,IAAAA,CAAAA,S;6BAAWC,U;MAAAA,UAAAA,GAAAA,eAAAA,KAAAA,KAAAA,CAAAA,GAAa,KAAbA,GAAa,e;;kBAExBG,QAAQ,E;MAA7BF,MAAAA,GAAAA,SAAAA,CAAAA,CAAAA,C;MAAQC,SAAAA,GAAAA,SAAAA,CAAAA,CAAAA,C;;AACf,MAAME,GAAG,GAAGC,MAAZ,EAAA;AACA,MAAMC,YAAY,GAAGD,MAArB,EAAA;AAEAE,EAAAA,SAAS,CAAC,YAAA;AACR,QAAIC,OAAO,GAAG;AACZC,MAAAA,IAAI,EADQ,IAAA;AAEZT,MAAAA,UAAU,EAFE,UAAA;AAGZD,MAAAA,SAAS,EAAEA;AAHC,KAAd;AAMAO,IAAAA,YAAY,CAAZA,OAAAA,GAAuB,IAAA,oBAAA,CAAyB,UAAA,OAAA,EAAA;AAC9C,UAAIL,MAAM,KAAKS,OAAO,CAAPA,CAAO,CAAPA,CAAf,cAAA,EAA0C;AACxCR,QAAAA,SAAS,CAACQ,OAAO,CAAPA,CAAO,CAAPA,CAAVR,cAAS,CAATA;AACD;AAHoB,KAAA,EAAvBI,OAAuB,CAAvBA;AAPO,GAAA,EAATC,EAAS,CAATA;AAcAA,EAAAA,SAAS,CAAC,YAAA;AACR;AACA,QAAIH,GAAG,CAAP,OAAA,EAAiBE,YAAY,CAAZA,OAAAA,CAAAA,OAAAA,CAA6BF,GAAG,CAAhCE,OAAAA;AACjB,WAAO,YAAA;AACL,UAAIF,GAAG,CAAP,OAAA,EAAiB;AACf;AACAE,QAAAA,YAAY,CAAZA,OAAAA,CAAAA,SAAAA,CAA+BF,GAAG,CAFnB,OAEfE,EAFe,CAAA;;AAIfA,QAAAA,YAAY,CAAZA,OAAAA,CAAAA,UAAAA;AACD;AANH,KAAA;AAHO,GAAA,EAWN,CAACF,GAAG,CAXPG,OAWG,CAXM,CAATA;AAaA,SAAO;AAAEN,IAAAA,MAAM,EAAR,MAAA;AAAUG,IAAAA,GAAG,EAAHA;AAAV,GAAP;AACD","sourcesContent":["import { useState, useRef, useEffect } from \"react\";\n\ntype ObserverType = {\n  threshold: number,\n  rootMargin?: string,\n};\n\nexport function useObserver({ threshold, rootMargin = '0px' }: ObserverType) {\n\n  const [inView, setInView] = useState<boolean>();\n  const ref = useRef<any>();\n  const iObserverRef = useRef<IntersectionObserver>();\n\n  useEffect(() => {\n    let options = {\n      root: null,\n      rootMargin: rootMargin,\n      threshold: threshold\n    }\n    \n    iObserverRef.current = new IntersectionObserver((entries) => {\n      if (inView !== entries[0].isIntersecting) {\n        setInView(entries[0].isIntersecting);\n      }\n    }, options);\n  }, []);\n\n  useEffect(() => {\n    // @ts-ignore\n    if (ref.current) iObserverRef.current.observe(ref.current);\n    return () => {\n      if (ref.current) {\n        // @ts-ignore\n        iObserverRef.current.unobserve(ref.current);\n        // @ts-ignore\n        iObserverRef.current.disconnect();\n      }\n    }\n  }, [ref.current])\n\n  return { inView, ref };\n}"]},"metadata":{},"sourceType":"module"}